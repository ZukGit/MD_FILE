# A
##  android资源之res/raw和assets的异同
```
■ res/raw和assets的相同点：
   两者目录下的文件在打包后会原封不动的保存在apk包中，【不会被编译成二进制】。


■ res/raw和assets的不同点：
1、res/raw中的文件会被映射到R.java文件中，访问的时候直接使用资源ID即R.id.filename；assets文件夹下的文件不会被映射到R.java中，访问的时候需要AssetManager类
2、res/raw不可以有目录结构，而assets则可以有目录结构，也就是assets目录下可以再建立文件夹

■  读取文件资源：
1、读取res/raw下的文件资源，通过以下方式获取输入流来进行写操作
InputStream is = getResources().openRawResource(R.id.filename);  

2、读取assets下的文件资源，通过以下方式获取输入流来进行写操作

AssetManager am = null;
am = getAssets();
InputStream is = am.open("filename");
am.close();  //关闭AssetManager

```

## ADB命令对包 com.zukgit 进行 100次测试
```
adb shell monkey -p com.zukgit -v 100 
adb shell monkey -p net.micode.fileexplorer -v 100 

```
# B
# C
# D
# E
## Error 与 Exception
```
 Exception（异常  通常程序员造成） 分为:
1.检查异常： （编写源代码时需要显示的进行处理，在方法中try或者throws）
2.不检查异常  (运行时异常，如： NullPointerException 空指针 、io FileNotFoundException 异常，数组越界 IndexOutOfBoundsException )
              (ArithmeticException  算术运算异常 , IllegalArgumentException 传递非法参数异常 , NumberFormatException 数字格式异常 )
              (NegativeArraySizeException 创建一个大小为负数的数组错误异常  , ClassCastException 类型强制转换异常 )

java中关于对异常和错误的处理：
有一个顶层的父类 Throwable。一个对象只有是 Throwable 类的（直接或者间接）实例，他才是一个异常对象，才能被异常处理机制识别。

public class Exception extends Throwable {}
public class Error extends Throwable {}

public class Throwable implements Serializable {}



```

```
Error (错误 系统层面 一般系统层面): 
程序员无法通过程序改变的错误，多为jvm本身的错误。如堆溢出错误、栈溢出错误
```

<img src="http://host805073097.s507.pppf.com.cn/wp-content/image/xiaoxijie/Exception.png" width="88%" height="88%" />


<img src="http://host805073097.s507.pppf.com.cn/wp-content/image/xiaoxijie/Exception1.png" width="100%" height="100%" />




```
实践应用：

尽量不要捕获类似 Exception 这样的通用异常，而是应该捕获特定异常
不要生吞（swallow）异常。
了解一下Throw early, catch late 原则(早点抛出异常延迟抓取异常)  
【即 catch的顺序必须是子类RuntimeException必须在前  父类Exception在后  如果父类Exception在前 那么会报错 ，试用所有Error Exception】
性能方面来说：尽量不要一个大的 try 包住整段的代码、，利用异常控制代码流是影响效率的

```

类名     | 说明
-------- | ---
ClassCastException   |	 类型强制转换异常
ArithmeticExecption	    |  算术异常类
NegativeArrayException   |	 数组负下标异常
ArrayIndexOutOfBoundsException   |	数组下标越界异常
NumberFormatException   |	字符串转换为数字异常
FileNotFoundException   |	文件未找到异常
EOFException   |	文件已结束异常
SecturityException   |	违背安全原则异常
SQLException   |	操作数据库异常
IOException   |	输入输出异常
NoSuchMethodException   |	方法未找到异常
AbstractMethodError   |	抽象方法错误。当应用试图调用抽象方法时抛出
AssertionError   |	用来指示一个断言失败的情况
ClassCircularityError   |	在初始化一个类时，若检测到类之间循环依赖则抛出该异常
ClassFormatError   |	文件的内容不符合类的有效格式时抛出
Error   |	错误  是所有错误的基类 用于标识严重的程序运行问题
Exception   |InInitializerError  	初始化程序错误
IllegalAccessError   |	非法参数 违法访问错误  当一个应用试图访问 、修改某个类的域（Field）或者调用其方法,但是又违反域或方法的可见性声明
IncompatibleClassChangeError   |	不兼容的类变化错误 当正在执行的方法所依赖的类定义发生了不兼容的改变时 抛出该异常
InstantiationError   |	实例化错误 new操作符构造一个抽象类或者接口时抛出该异常
InternalError   |	内部错误 用于指示 java虚拟机发生了内部错误
LinkageError   |	链接错误 该错误及其所有子类指示某个类依赖于另外一些类 在该类编译之后 被依赖的类改变了其类定义而没有重新编译所有的类
NoClassDefFoundError   |	未找到类定义错误
NoSuchFieldError   |	域不存在错误 该类的定义中没有该域的定义时抛出该错误
NoSuchMethodError   |	方法不存在错误
OutOfMemoryError   |	内存不足错误
StackOverflowError   |	堆栈溢出错误
ThreadDeath	 | 线程结束 当调用Thread类的stop方法时抛出该错误 用于指示线程结束
UnknownError   |	未知错误 java 虚拟机发生了未知严重错误的情况
UnsatisfiedLinkError   |	未满足的链接错误 java虚拟机未找到某个类的声明为native方法的本机语言定义时抛
UnsupportedClassVersionError   |	不支持的类版本错误
VerifyError   |	验证错误
VirtualMachineError   |	虚拟机错误 继续执行操作所需的资源不足的情况
RuntimeException   |	是那些可能在 Java 虚拟机正常运行期间抛出的异常的超类可能在执行方法期间抛出但未被捕获的RuntimeException   |的任何子类都无需在throws子句中进行声明
ClassNotFoundException   |	找不到数据库驱动类
CloneNotSupportedException   |	克隆 不支持
InterruptedException   |	线程被中断异常
StringIndexOutOfBoundsException   |	字符串越界
UnsupportedOperationException   |	该操作不被支持，如果我们希望不支持这个方法，可以抛出这个异常
IllegalStateException   |	非法状态



```
Demo推导出的结论:
1. catch的顺序必须是子类RuntimeException必须在前  父类Exception在后  如果父类Exception在前 那么会报错 ，试用所有Error Exception
2. Error 和 Exception 都可以捕获，它们可以混搭捕获，但必须依据 子类在前原则
3. try 出现了Exception 之后  try{} 包含的代码块就会停止执行， 然后执行 对应的 Catch 和 finally方法  ，然后执行 try{}finally{}代码块之后的代码
4.  try 语句不能单独出现  必须 伴随着  try-catch    try-finally    try-catch-finally   三种形式出现，单独出现报错
5.  只要 try语句中包含finally 那么 不管是否在try语句中发生 Exception  Error  或者 在try 语句中有 return  ,只要程序不退出程序System.exit(0)，那么都会在 return 执行去执行 finally语句
6.  当try或者catch的代码在运行的时候，JVM退出了  如System.exit(0) 。那么finally语句块就不会执行。  
    如果线程在运行try或者catch的代码时被中断了或者被杀死了(killed)，那么finally语句可能也不会执行了
7. 如果程序抛出的异常没有被catch , 或者 该异常为子类 对应的 父类继承链 的所有家族类 都没有在catch 集合中 那么 程序在执行完 finally 后会 默认退出【即 System.exit(0)】
   抛出异常的try{} 后面的代码得不到执行 【 例子: 如下 ClassCastExceptionDemo 】
```
```
NumberFormatException: 
public class NumberFormatExceptionDemo {
	static int intValue = 1;

	public void MethodTryCatchFinally() {
		try {
			
		} catch (Exception e) {

		}

		try {

		} finally {

		}

	}

	
    public static int MethodTryExit() {
        int x = 1;

        try {
    		System.out.println("============= MethodTryExit try begin =============");
    		System.exit(0);
    		System.out.println("============= MethodTryExit try end =============");
        } catch (Exception e) {

        } finally {
    		System.out.println("============= MethodTryExit finally begin =============");
            ++x;
    		System.out.println("============= MethodTryExit finally end x="+x +  "=============");
        }
        return x;
    	
    }
	
    public static int MethodTryReturn() {
        int x = 1;

        try {
    		System.out.println("============= MethodTryReturn try begin =============");
            return ++x;
        } catch (Exception e) {

        } finally {
    		System.out.println("============= MethodTryReturn finally begin =============");
            ++x;
    		System.out.println("============= MethodTryReturn finally end x="+x +  "=============");
        }
        return x;
    }
    
    
	public static void main(String[] args) {
		System.out.println("============= main begin =============");
		
		int valueA = MethodTryReturn();

		try {
			System.out.println("============= try begin =============");
			intValue = Integer.parseInt("ABC");

			System.out.println("============= try end intValue=" + intValue);
			System.out.println("============= try end =============");
			return;
		}

		catch (OutOfMemoryError e) {
			System.out.println("============= catch OutOfMemoryError begin =============");
			e.printStackTrace();
			System.out.println("============= catch OutOfMemoryError end =============");
		}

		catch (NumberFormatException e) {
			System.out.println("============= catch NumberFormatException begin =============");
			e.printStackTrace();
			System.out.println("============= catch NumberFormatException end =============");
		}

		catch (IllegalArgumentException e) {
			System.out.println("============= catch IllegalArgumentException begin =============");
			e.printStackTrace();
			System.out.println("============= catch IllegalArgumentException end =============");
		}

		catch (RuntimeException e) {
			System.out.println("============= catch RuntimeException begin =============");
			e.printStackTrace();
			System.out.println("============= catch RuntimeException end =============");
		}

		catch (Exception e) {
			System.out.println("============= catch Exception begin =============");
			e.printStackTrace();
			System.out.println("============= catch Exception end =============");
		}

		catch (Error e) {
			System.out.println("============= catch Error begin =============");
			e.printStackTrace();
			System.out.println("============= catch Error end =============");
		}

		finally {
			System.out.println("============= finally begin =============");
			intValue = 0;
			System.out.println("============= finally end =============");

		}
		
		int valueB = MethodTryExit();
		System.out.println("============= main end-intValue =" + intValue);
		System.out.println("============= main end =============");
	}
}

/**
输出：
============= main begin =============
============= MethodTryReturn try begin =============
============= MethodTryReturn finally begin =============
============= MethodTryReturn finally end x=3=============
============= try begin =============
============= catch NumberFormatException begin =============
java.lang.NumberFormatException: For input string: "ABC"
	at java.lang.NumberFormatException.forInputString(Unknown Source)
	at java.lang.Integer.parseInt(Unknown Source)
	at java.lang.Integer.parseInt(Unknown Source)
	at test.NumberFormatExceptionDemo.main(NumberFormatExceptionDemo.java:64)
============= catch NumberFormatException end =============
============= finally begin =============
============= finally end =============
============= MethodTryExit try begin =============
**/

```

```
 ClassCastException  extends RuntimeException  【强制转化异常】
public class ClassCastExceptionDemo {

	public static void MethodCatch(int index) {
		System.out.println("=============MethodCatch begin=============");
		try {
			if (index > 100)
				throw new NumberFormatException("超过数组长度越界");
		} 
		catch(RuntimeException e) {
			System.out.println("=============MethodCatch  catch begin=============");
		    e.printStackTrace();
			System.out.println("=============MethodCatch  catch end=============");
		}
		finally {
			System.out.println("=============MethodCatch  finally begin=============");
			System.out.println("=============MethodCatch  finally end=============");
		}
		System.out.println("=============MethodCatch end=============");
	}

	
	public static void MethodNoCatch(int index) {
		System.out.println("=============MethodNoCatch begin=============");
		try {
			if (index > 100)
				throw new NumberFormatException("超过数组长度越界");
		} 
		catch(NullPointerException e) {
			System.out.println("=============MethodNoCatch  catch begin=============");
		    e.printStackTrace();
			System.out.println("=============MethodNoCatch  catch begin=============");
		}
		finally {
			System.out.println("=============MethodNoCatch  finally begin=============");
			System.out.println("=============MethodNoCatch  finally end=============");
		}
		System.out.println("=============MethodNoCatch end=============");
	}
	
	
	public static void main(String[] args) {
		System.out.println("============== main  begin ==============");
		MethodCatch(101);

		try {
			System.out.println("============== main  try begin ==============");
			Object x = new Integer(0);
			System.out.println((String) x);
			System.out.println("============== main  try end ==============");
		} catch (ClassCastException e) {
			e.printStackTrace();
		} finally {
			System.out.println("============== main finally begin ==============");
			System.out.println("============== main finally end ==============");
		}
		MethodNoCatch(101);
		System.out.println("============== main  end ==============");
	}

}

/*
输出：
============== main  begin ==============
=============MethodCatch begin=============
=============MethodCatch  catch begin=============
java.lang.NumberFormatException: 超过数组长度越界
	at test.ClassCastExceptionDemo.MethodCatch(ClassCastExceptionDemo.java:9)
	at test.ClassCastExceptionDemo.main(ClassCastExceptionDemo.java:45)
=============MethodCatch  catch end=============
=============MethodCatch  finally begin=============
=============MethodCatch  finally end=============
=============MethodCatch end=============
============== main  try begin ==============
java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String
	at test.ClassCastExceptionDemo.main(ClassCastExceptionDemo.java:50)
============== main finally begin ==============
============== main finally end ==============
=============MethodNoCatch begin=============
=============MethodNoCatch  finally begin=============
=============MethodNoCatch  finally end=============
Exception in thread "main" java.lang.NumberFormatException: 超过数组长度越界
	at test.ClassCastExceptionDemo.MethodNoCatch(ClassCastExceptionDemo.java:28)
	at test.ClassCastExceptionDemo.main(ClassCastExceptionDemo.java:58)
*/

```

```
java中异常抛出后代码还会继续执行吗:
总结：
若一段代码前有异常抛出，并且这个异常没有被捕获，这段代码将产生编译时错误「无法访问的语句」。
若一段代码前有异常抛出，并且这个异常被try...catch所捕获 父子链成员补货，若此时catch语句中没有抛出新的异常，则这段代码能够被执行，否则，同第1条。如代码2
若在一个条件语句中抛出异常，则程序能被编译，但后面的语句不会被执行。如代码3 


```

# F
# G
## GC
```
 虚拟机中的共划分为三个代：年轻代（Young Generation）、老年代（Old Generation）和持久代（Permanent Generation）

```
# H
## HashMap的数据结构
[HashMap的数据结构](https://blog.csdn.net/huaxun66/article/details/53036625)
```
HashMap 产生的缘由： 要了解 HashMap 产生的缘由 先了解 数组和链表各自的特点：

数组的特点是：寻址容易，插入和删除困难；
链表的特点是：寻址困难，插入和删除容易；
那么我们能不能综合两者的特性，做出一种寻址容易，插入删除也容易的数据结构？答案是肯定的，这就是我们要提起的哈希表
哈希表有多种不同的实现方法，我接下来解释的是最常用的一种方法—— ■拉链法，我们可以理解为“链表的数组”，如图：
```
<img src="http://host805073097.s507.pppf.com.cn/wp-content/image/xiaoxijie/hashMap.png">

```
从上图我们可以发现哈希表是由数组+链表组成的，一个长度为16的数组中，■数组的每个元素存储的是一个链表的头结点。
元素存储到数组中的规则：
一般情况是通过hash(key)%len获得，也就是元素的key的哈希值对数组长度取模得到
比如上述哈希表中，12%16=12,28%16=12,108%16=12,140%16=12。所以12、28、108以及140都存储在数组下标为12的位置。


```



```
public interface Map<K, V> {  // 【接口内部定义接口?】
    void clear();
    boolean containsKey(Object var1);
    boolean containsValue(Object var1);
    Set<Map.Entry<K, V>> entrySet();
    boolean equals(Object var1);
    V get(Object var1);
    int hashCode();
    boolean isEmpty();
    Set<K> keySet();
    V put(K var1, V var2);
    void putAll(Map<? extends K, ? extends V> var1);
    V remove(Object var1);
    int size();
    Collection<V> values();

    public interface Entry<K, V> {
        boolean equals(Object var1);
        K getKey();
        V getValue();
        int hashCode();
        V setValue(V var1);
    }
}

```

```
HashMap的存取实现:

//存储时:
int hash = key.hashCode();// 这个hashCode方法这里不详述,只要理解每个key的hash是一个固定的int值
int index = hash % Entry[].length;
Entry[index] = value;

//取值时:
int hash = key.hashCode();
int index = hash % Entry[].length;
return Entry[index];
```
<img src="https://img-blog.csdn.net/20161107141540634">
```
HASH 冲突：
如果两个key通过hash%Entry[].length得到的index相同（也称为hash冲突），会不会有覆盖的危险？ 

键值对A ：   A.hashCode()%length = 0;  Entry[0] = A;
键值对B ：   B.hashCode()%length = 0;   索引一致： 那么冲突  执行：  B.next = A;  Entry[0] = B;
键值对C ：   C.hashCode()%length = 0;   索引一致： 那么冲突  执行：  C.next = B;  Entry[0] = C;

注：解决hash冲突的办法：
开放定址法（线性探测再散列，二次探测再散列，伪随机探测再散列）
再哈希法
链地址法 【Java 默认】
建立一个公共溢出区
```

```
HashMap的优化:
Entry[]的长度一定固定后，随着map里面数据的越来越长，这样同一个index的链就会很长，会不会影响性能？
HashMap里面设置一个因素（■也称为负载极限 负载因子），随着map的size越来越大，Entry[]会以一定的规则加长长度。 
public HashMap(int capacity, float loadFactor) // HashMap 的构造器中设置  负载因子 loadFactor  默认 0.75
HashMap map = new HashMap(10, 0.8F);   
//容量极限threshold=(int)(capacity*loadFacor);   当超过时就会增长一倍的长度resize(2*table.length);   
HashMap默认的“负载极限”为0.75，表明该hash表3/4已经被填满时，hash表会发生rehashing
0.75其实是事件和空间的一个折中：
较高的“负载极限”可以降低hash表所占的内存空间，但会增加查询数据的开销，而查询是最频繁的操作；
而较低的“负载极限”会增加查询的性能，但会增加hash表所占的内存空间。

```

## HashMap Hashtable SynchronizedMap和ConcurrentHashMap关系
HashMap、Hashtable、SynchronizedMap和ConcurrentHashMap关系
```
HashMap 与 Hashtable：
1. 不同点
一：
HashMap允许使用null作为key或者value，          
Hashtable 不允许使用null 作为key 或者 value

二：
并且HashMap不是线程安全的  因为HashMap 定义的方法 都没有 synchronized 限制词修饰
Hashtable是线程安全的      因为Hashtable 定义的方法 全是 synchronized 限制词修饰


public static void main(String[] args) {
	HashMap map = new HashMap();
	map.put(null, null);
	map.put("map_key", null);
	map.put(null, "map_value");  // Key 相同 覆盖了上面的 map.put(null, null);  所以 Map的size为2
	System.out.println(map.size());
	
	
	Hashtable tab = new Hashtable();
	tab.put(null, null);   【 往Hashtable 放空指针 会导致方法调用报错  】
	tab.put("tab_key", null);
	tab.put(null, "tab_value");
	System.out.println(tab.size());
}

输出：

2
Exception in thread "main" java.lang.NullPointerException
	at java.util.Hashtable.put(Unknown Source)
	at test.MemoryCache.main(MemoryCache.java:17)



```


```
HashMap、Hashtable、SynchronizedMap和ConcurrentHashMap关系

HashMap不是线程安全的；
Hashtable线程安全，但效率低，因为是Hashtable是使用synchronized的，所有线程竞争同一把锁；
SynchronizedMap线程安全，其实是保持外部同步来实现的，效率也很低；
而ConcurrentHashMap不仅线程安全而且效率高，因为它包含一个segment数组，将数据分段存储，给每一段数据配一把锁，也就是所谓的锁分段技术。


如何线程安全的使用HashMap，无非就是以下三种方式：
Hashtable
Synchronized Map
ConcurrentHashMap


```



# I

## Integer 封装 int 的缓存问题
```
Integer A1=  100；
Integer A2=  100；
A1 == A2   【 TRUE 】

Integer B1=  200；
Integer B2=  200；

B1 == B2   【 FALSE 】

// 当直接赋值int 数据类型给  Integer 时   JAVA 会自动封装int 为 Integer类   同时缓存  -128 至 127 封装的对象
// 当下次创建时  需要JVM 封装相同的 int值  就不创建Integer 对象  而是直接 用原来的对象 来处理
public class Integet_Test {


	public static void main(String[] args) {

		Integer A1=  new Integer(11);
		Integer A2=  new Integer(11);
		System.out.println(A1==A2?" A1 == A2":" A1! = A2");

		Integer B1=  new Integer(200);
		Integer B2=  new Integer(200);
		System.out.println(B1==B2?" B1 == B2":" B1! = B2");
		
		Integer C1=  0;  
		Integer C2=  0;	
		System.out.println(C1==C2?" C1 == C2":" C1! = C2");	
		
		Integer D1=  -128;
		Integer D2=  -128;	
		System.out.println(D1==D2?" D1 == D2":" D1! = D2");	
		
		
		Integer E1=  127;
		Integer E2=  127;	
		System.out.println(E1==E2?" E1 == E2":" E2! = E2");	
		
		Integer F1=  200;
		Integer F2=  200;	
		System.out.println(F1==E2?" F1 == F2":" F1 != F2");	
}
	
}

/*
 * 输出：
 * 
 A1! = A2
 B1! = B2
 C1 == C2
 D1 == D2
 E1 == E2
 F1 != F2
 * 
 * 
 * 
 * */
```

## Interface接口中定义接口的问题(其实就是定义两个接口)
【接口内定义接口其实就是两个接口】
```
// 这个没有怎么回事，接口内定义接口其实就是两个接口。因为接口永远都是public的，
//只能说这样的写法风格不好。更好的写法是将两个接口单独使用两个类文件进行定义。
public interface InterfaceA {

	void interfaceA_Method();
	
	interface InterfaceA_ChildA {
		void InterfaceA_ChildA_Method();
	
	}
}



public class ObjectA implements InterfaceA.InterfaceA_ChildA{

	@Override
	public void InterfaceA_ChildA_Method() {
		System.out.println("ObjectA [InterfaceA_ChildA_Method ] ");
	}

	public class ObjectA_ChildA implements InterfaceA{

		@Override
		public void interfaceA_Method() {
			System.out.println("ObjectA_ChildA[ interfaceA_Method() ]");
		}
	}
	
	public static void main(String[] args) {
		ObjectA_ChildA  mObjectA_ChildA = (new ObjectA()). new ObjectA_ChildA();  //创建内部实例类
		mObjectA_ChildA.interfaceA_Method();
		
		
		ObjectA mObjectA = new ObjectA();
		mObjectA.InterfaceA_ChildA_Method();
	}
}


输出： 
ObjectA_ChildA[ interfaceA_Method() ]
ObjectA [InterfaceA_ChildA_Method ] 
```

## i++ 与 ++i 问题
```
package test;

public class NumPlusPlus {
	int intA;
	int intB;
	int intC;
	int intD;

	static int[][] intArr = { { 1, 2, 3, 10 }, { 4, 5, 6, 100 }, { 7, 8, 9, 1000 } };

	public static void main(String[] args) {
		NumPlusPlus obj = new NumPlusPlus();
		System.out.println("A++  A++ ([1][2])=" + intArr[obj.intA++][obj.intA++]);
		System.out.println("B++  ++B ([1][3])= " + intArr[obj.intB++][++obj.intB]);
		System.out.println("++C  C++ ([2][2])= " + intArr[++obj.intC][obj.intC++]);
		System.out.println("++D  ++D ([2][3])= " + intArr[++obj.intD][++obj.intD]);
	}

	{

		intA = 1;
		intB = 1;
		intC = 1;
		intD = 1;
	}
}


输出： 
A++  A++ ([1][2])=6
B++  ++B ([1][3])= 100
++C  C++ ([2][2])= 9
++D  ++D ([2][3])= 1000


结论:
i++  先赋值  再自增   原子性的    所以遇到的下一个 i必须是 增1的值
++i  先自增  再赋值   原子性的   所以遇到的下一个 i必须是 增1的值


```


## IO流
<img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1530293798360&di=1f8bb4a23bfeed268d53145b2eab7881&imgtype=0&src=http%3A%2F%2Fwww.codedou.com%2Fwp-content%2Fuploads%2F2017%2F04%2F2502942685-57fdeddf4aac4_articlex.png">
```

```


# J
# K
# L
## LinkList对应的linknode的逆序 Java实现
<img src="http://host805073097.s507.pppf.com.cn/wp-content/image/xiaoxijie/LinkNodeRev.png ">
```
思路:  把linkList分为新旧两个链表  分别更新新旧链表的表头  
       同时需要把当前操作的node 添加的新链表的头结点之前 使其成为新的表头 
重点代码：

			LinkNode newHead = head;
			LinkNode newHeadTail = head;
			LinkNode oldHead = head;
			while(oldHead != null )
			{
				LinkNode cur = oldHead; //  获得当前操作的 LinkNode
				oldHead = cur.next;    // 设置oldHead 新的起点
				
				// 相当于的头指针前加一个node 使得这个node 变成头指针
				LinkNode newHeadTemp = newHeadTail; // 保存当前的头结点  
				newHeadTail = cur ;  // 对当前的Node进行处理  新的尾巴
				newHeadTail.next = newHeadTemp;  // CurNode  和  newHeadTail 建立关系
			}
			newHead.next = null;






public class LinkNode {
	public int value;
	public LinkNode next;
}






public class ReverseListObj {

	public static void main(String[] args) {
		LinkNode head = new LinkNode();
		head.value = 0;
		head.next = null;
		LinkNode temp = head;
		for(int i=1;i<10;i++) {
			LinkNode node = new LinkNode();
			node.value = i;
			node.next = null;
			temp.next = node;
			temp = node;
		}
		System.out.println("============main  printList 打印原始Link结点   Begin=================");
		printList(head);
		System.out.println("============main  printList 打印原始Link结点   End=================");
		System.out.println();
		System.out.println("========main  printReverseList_Stack 使用堆栈逆序打印LinkList   Begin======");
		printReverseList_Stack(head);
		System.out.println("========main  printReverseList_Stack 使用堆栈逆序打印LinkList   End======");
		System.out.println();
		
		System.out.println("========main  printReverseList_Recursion 使用递归逆序打印LinkList   Begin======");
		printReverseList_Recursion(head);

		System.out.println("========main  printReverseList_Recursion 使用递归逆序打印LinkList   End======");

		
		
		System.out.println();
		System.out.println("========main  reverseLinkNodeList 对当前的LinkList进行逆序重排 头尾交换   Begin======");
		LinkNode newHead = reverseLinkNodeList(head);
		printList(newHead);
		System.out.println("========main  reverseLinkNodeList 对当前的LinkList进行逆序重排 头尾交换   End======");
		

	}
	
	
	
	
	/**
	 * 
	 * @Title: reverseLinkNodeList 
	 * @Description: 对链表进行逆序使得由头变为 由尾变头
	 * @param  LinkNode head   
	 * @return LinkNode newHead    
	 * @throws
	 */
		public static LinkNode reverseLinkNodeList(LinkNode head)
		{
			System.out.println("===============reverseLinkNodeList  Begin=================");
			if(head == null || head.next == null)
				return head;
			
			LinkNode newHead = head;
			LinkNode newHeadTail = head;
			LinkNode oldHead = head;
			
			while(oldHead != null )
			{
				LinkNode cur = oldHead; //  获得当前操作的 LinkNode
				oldHead = cur.next;    // 设置oldHead 新的起点
				
				// 相当于的头指针前加一个node 使得这个node 变成头指针
				LinkNode newHeadTemp = newHeadTail; // 保存当前的头结点  
				newHeadTail = cur ;  // 对当前的Node进行处理  新的尾巴
				newHeadTail.next = newHeadTemp;  // CurNode  和  newHeadTail 建立关系
			}
			newHead.next = null;
			System.out.println("===============reverseLinkNodeList  End=================");
			return newHeadTail;
			

		}
	
	/**
	 * 
	 * @Title: printList 
	 * @Description: 正常输出链表(递归实现）
	 * @param head   
	 * @return void     
	 * @throws
	 */
	private static void printList(LinkNode head) {
		System.out.println("===============printList  Begin=================");
		if(head==null)return;
		LinkNode mLinkNode= head;
		while(mLinkNode.next!=null) {
			System.out.print(mLinkNode.value+" ");
			mLinkNode = mLinkNode.next;
		} 
		System.out.print(mLinkNode.value+" ");
		System.out.println("");
		System.out.println("===============printList  End=================");

	}

	
	
	/**
	 * 
	 * @Title: printReverseList_Recursion 
	 * @Description: 反向输出链表(递归实现）
	 * @param head   
	 * @return void     
	 * @throws
	 */
	private static void printReverseList_Recursion(LinkNode head) {
		if(head==null)return;
		if(head.next!=null) {
			printReverseList_Recursion(head.next);
		} 
		System.out.print(head.value+" ");
		
	}




	/**
	 * 
	 * @Title: printReverseList 
	 * @Description:反向输出链表 (栈实现)
	 * @param head   
	 * @return void     
	 * @throws
	 */
	private static void printReverseList_Stack(LinkNode head) {

		System.out.println("===============printReverseList_Stack  Begin=================");
		if(head == null) return;
		Stack<Integer> stack = new Stack();
		// 遍历链表
		LinkNode temp = head;
		while(temp != null) {
			stack.add(temp.value);
			temp = temp.next;
		}
		while(!stack.isEmpty()) {
			if(stack.size()!=1) {
				System.out.print(stack.pop()+",");
			}else {
				System.out.print(stack.pop());
			}
		}
		System.out.println("");
		System.out.println("===============printReverseList_Stack  End=================");
	}
}


/*
输出：
============main  printList 打印原始Link结点   Begin=================
===============printList  Begin=================
0 1 2 3 4 5 6 7 8 9 
===============printList  End=================
============main  printList 打印原始Link结点   End=================

========main  printReverseList_Stack 使用堆栈逆序打印LinkList   Begin======
===============printReverseList_Stack  Begin=================
9,8,7,6,5,4,3,2,1,0
===============printReverseList_Stack  End=================
========main  printReverseList_Stack 使用堆栈逆序打印LinkList   End======

========main  printReverseList_Recursion 使用递归逆序打印LinkList   Begin======
9 8 7 6 5 4 3 2 1 0 ========main  printReverseList_Recursion 使用递归逆序打印LinkList   End======

========main  reverseLinkNodeList 对当前的LinkList进行逆序重排 头尾交换   Begin======
===============reverseLinkNodeList  Begin=================
===============reverseLinkNodeList  End=================
===============printList  Begin=================
9 8 7 6 5 4 3 2 1 0 
===============printList  End=================
========main  reverseLinkNodeList 对当前的LinkList进行逆序重排 头尾交换   End======

*/







```
# M
# N
## 内存泄漏
```
内存泄漏有两种情况:
1: 一种情况如在C/C++语言中的，在堆中的分配的内存，在没有将其释放掉的时候，就将所有能访问这块内存的方式都删掉（如指针重新赋值）
2: 另一种情况则是在内存对象明明已经不需要的时候，还仍然保留着这块内存和它的访问方式（引用）
   第一种情况，在Java中已经由于垃圾回收机制的引入，得到了很好的解决。所以，Java中的内存泄漏，主要指的是第二种情况

内存泄漏的例子：
Vector v=new Vector(10);
for (int i=1;i<100; i++){
Object o=new Object();
v.add(o);
o=null;
}

Vector的容量之所以重要，有以下两个原因：
 1. 容器的大小一旦超过capacity的大小，vector会重新配置内部的存储器，导致和vector元素相关的所有reference、pointers、iterator都会失效。

分析：
代码栈中存在引用 Vector v 和 引用 Object o
在For循环中，我们不断的生成新的对象，然后将其添加到Vector对象中，之后将o引用置空

问题是当o引用被置空后，如果发生GC，我们创建的Object对象是否能够被GC回收呢？
答案是否定的。 GC不能收回Object对象。
因为，GC在跟踪代码栈中的引用时，会发现v引用，而继续往下跟踪，就会发现v引用指向的内存空间中又存在指向Object对象的引用。
也就是说尽管o引用已经被置空，但是Object对象仍然存在其他的引用，是可以被访问到的，所以GC无法将其释放掉。
因此，如果对象加入到Vector 后，还必须从 Vector 中删除，最简单的方法就是将 Vector 对象设置为 null。
```
```
内存泄漏分类:
1、静态集合类引起内存泄漏：
像HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，他们所引用的所有的对象Object也不能被释放，因为他们也将一直被Vector等引用着。


2.各种连接

3. Handler 造成的内存泄漏
 Handler 发送的 Message 尚未被处理，则该 Message 及发送它的 Handler 对象将被线程 MessageQueue 一直持有。
由于 Handler 属于 TLS(Thread Local Storage) 变量, 生命周期和 Activity 是不一致的。因此这种实现方式一般很难保证跟 View 或者 Activity 的生命周期保持一致，故很容易导致无法正确释放。
```
# O
## override(覆盖) overload(重载) overwrite(重写)
区别：
<img src="http://host805073097.s507.pppf.com.cn/wp-content/image/xiaoxijie/override_diff.jpg">
**覆盖 override 的情况汇总：**
<img src="http://host805073097.s507.pppf.com.cn/wp-content/image/xiaoxijie/overide.jpg">
```
覆盖（override）:
继承了父类的同名无參函数：当子类从父类继承一个无參方法，而又定义了一个同样的无参数的方法时，
则子类新写的方法覆盖父类的方法，成为覆盖。 【 override 覆盖】

Class Father{ Methid(); static Static_Method()};
Class Child extend Father{Methid();}; // 非静态内部类无法编写 静态方法
Class static StaticChild extend Father{ Methid(); static Static_Method() };
总结：
1. 父类引用非静态子类  Father fatherRef = new Child();
   fatherRef.Method()         输出===》 Child_Method
   fatherRef.Static_Method()  输出===》  Father_Static_Method

2. 子类引用非静态子类      Child childRef = new Child();
   childRef.Method()         输出===》 Child_Method
   childRef.Static_Method()  输出===》  Father_Static_Method

3. 父类引用静态子类     Father fatherRef_static = new StaticChild();
   fatherRef_static.Method()         输出===》 StaticChild_Method
   fatherRef_static.Static_Method()  输出===》  Father_Static_Method

4. 子类引用静态子类   StaticChild childRef_static = new StaticChild();
    childRef_static.Method()         输出===》  StaticChild_Method
    childRef_static.Static_Method()  输出===》  StaticChild_Static_Method

例子：

package test;

public class OverrideObjFather {

	public void zukgitMethod(){
		System.out.println("OverrideObjFather.zukgitMethod_Object");
	}
	

	public static void zukgitMethod_static(){
		System.out.println("OverrideObjFather.zukgitMethod_StaticClass");
	}
	
	
	public class OverrideObjChildObj extends OverrideObjFather{
		
		public void zukgitMethod(){
			System.out.println("OverrideObjChildObj.zukgitMethod_Object");
		}	
	}
	
	
	public static class OverrideObjChildStaticClass  extends OverrideObjFather{
		public void zukgitMethod(){
			System.out.println("OverrideObjChildStaticClass.zukgitMethod_Object");
		}	
		
		public static void zukgitMethod_static(){
			System.out.println("OverrideObjChildStaticClass.zukgitMethod_StaticClass");
		}
	}
	
	public static void main(String[] args) {
		System.out.println("==================Father f = new Child();  父类引用指向子类 Begin===========");
		OverrideObjFather fatherRefChild = (new OverrideObjFather()).new OverrideObjChildObj();
		System.out.println("==========父类引用子类对象.zukgitMethod() begin ========");
		fatherRefChild.zukgitMethod();
		System.out.println("==========父类引用子类对象.zukgitMethod() end ========");
		
		System.out.println("==========父类引用子类对象.zukgitMethod_static() begin ========");
		fatherRefChild.zukgitMethod_static();
		System.out.println("==========父类引用子类对象.zukgitMethod_static() end ========");
		System.out.println("==================Father f = new Child();  父类引用指向子类 End===========");
		
		System.out.println("==================Child c = new Child(); 子类引用指向子类  Begin========");
		OverrideObjChildObj childRefChild = (new OverrideObjFather()).new OverrideObjChildObj();
		System.out.println("==========子类引用子类静态对象.zukgitMethod() begin ========");
		childRefChild.zukgitMethod();
		System.out.println("==========子类引用子类静态对象.zukgitMethod() end ========");
		
		
		System.out.println("==========子类引用子类静态对象.zukgitMethod_static() begin ========");
		childRefChild.zukgitMethod_static();
		System.out.println("==========子类引用子类静态对象.zukgitMethod_static() end ========");
		System.out.println("==================Child c = new Child(); 子类引用指向子类  End========");
		
		
		System.out.println("#################################################");
		System.out.println("==================Father f = new Child_Static();  父类引用指向静态子类对象  Begin===========");
		OverrideObjFather fatherRefChild_Static = new OverrideObjFather.OverrideObjChildStaticClass();
		System.out.println("==========父类引用静态子类对象.zukgitMethod() begin ========");
		fatherRefChild_Static.zukgitMethod();
		System.out.println("==========父类引用静态子类对象.zukgitMethod() end ========");
		
		System.out.println("==========父类引用静态子类对象.zukgitMethod_static() begin ========");
		fatherRefChild_Static.zukgitMethod_static();
		System.out.println("==========父类引用静态子类对象.zukgitMethod_static() end ========");
		
		
		System.out.println("==================Father f = new Child_Static();  父类引用指向静态子类对象  End===========");
		
		System.out.println("==================Child c = new Child()_Static; 子类引用指向子类  Begin========");
		OverrideObjChildStaticClass childRefChild_Static = new OverrideObjFather.OverrideObjChildStaticClass();
		System.out.println("==================Child c = new Child()_Static; zukgitMethod   Begin========");
		childRefChild_Static.zukgitMethod();
		System.out.println("==================Child c = new Child()_Static; zukgitMethod   End========");
		
		System.out.println("==================Child c = new Child()_Static; zukgitMethod_static   Begin========");
		childRefChild_Static.zukgitMethod_static();
		System.out.println("==================Child c = new Child()_Static; zukgitMethod_static   End========");
		System.out.println("==================Child c = new Child()_Static; 子类引用指向子类  Begin========");
		
	}
}


/*
输出

==================Father f = new Child();  父类引用指向子类 Begin===========
==========父类引用子类对象.zukgitMethod() begin ========
OverrideObjChildObj.zukgitMethod_Object
==========父类引用子类对象.zukgitMethod() end ========
==========父类引用子类对象.zukgitMethod_static() begin ========
OverrideObjFather.zukgitMethod_StaticClass
==========父类引用子类对象.zukgitMethod_static() end ========
==================Father f = new Child();  父类引用指向子类 End===========
==================Child c = new Child(); 子类引用指向子类  Begin========
==========子类引用子类静态对象.zukgitMethod() begin ========
OverrideObjChildObj.zukgitMethod_Object
==========子类引用子类静态对象.zukgitMethod() end ========
==========子类引用子类静态对象.zukgitMethod_static() begin ========
OverrideObjFather.zukgitMethod_StaticClass
==========子类引用子类静态对象.zukgitMethod_static() end ========
==================Child c = new Child(); 子类引用指向子类  End========
#################################################
==================Father f = new Child_Static();  父类引用指向静态子类对象  Begin===========
==========父类引用静态子类对象.zukgitMethod() begin ========
OverrideObjChildStaticClass.zukgitMethod_Object
==========父类引用静态子类对象.zukgitMethod() end ========
==========父类引用静态子类对象.zukgitMethod_static() begin ========
OverrideObjFather.zukgitMethod_StaticClass
==========父类引用静态子类对象.zukgitMethod_static() end ========
==================Father f = new Child_Static();  父类引用指向静态子类对象  End===========
==================Child c = new Child()_Static; 子类引用指向子类  Begin========
==================Child c = new Child()_Static; zukgitMethod   Begin========
OverrideObjChildStaticClass.zukgitMethod_Object
==================Child c = new Child()_Static; zukgitMethod   End========
==================Child c = new Child()_Static; zukgitMethod_static   Begin========
OverrideObjChildStaticClass.zukgitMethod_StaticClass
==================Child c = new Child()_Static; zukgitMethod_static   End========
==================Child c = new Child()_Static; 子类引用指向子类  Begin========


*/


```


```
重载Overload： 同名不同参数
package test;

public class OverLoadObj { // overload 重载

	public void doSomeThing(int a) {
		System.out.println("OverLoadObj doSomeThing a=:" + a);
	}

	public void doSomeThing(int a , int b) {    // 同一个类之间的重载
		System.out.println("OverLoadObj doSomeThing a=:" + a+ ", b = " + b);
	}

	
	
	class OverLoadObj_SubClass extends OverLoadObj {
		public void doSomeThing(int a, int b , int c) {   // 父子类之间的重载
			System.out.println("OverLoadObj_SubClass doSomeThing: a" + a + ", b = " + b+ " , c ="+c);
		}
	}

	public static void main(String[] args) {
		OverLoadObj_SubClass sub = (new OverLoadObj()).new OverLoadObj_SubClass();
		sub.doSomeThing(0);
		sub.doSomeThing(1, 2 , 3);
	}

}


/*  输出：

OverLoadObj doSomeThing a=:0
OverLoadObj_SubClass doSomeThing: a1, b = 2 , c =3



*/

```
# P
## public
<img src ="http://host805073097.s507.pppf.com.cn/wp-content/image/xiaoxijie/public.jpg">
# Q
# R
# S
## SharePreference 的异步apply写入磁盘操作  同步commit写入磁盘操作
```
SharedPreferences(后续简称SP)为我们提供了轻量级存储能力，方便了少量数据的持久化。
SharedPreferences保存数据，其背后是用xml文件存放数据，文件存放在/data/data/<package name>/shared_prefs目录下：
但是由于项目越来越庞大，SP操作使用不当会导致app卡顿，乃至ANR问题。


SP性能优化点
SP性能变差的原因有很多。
1.原生API的限制主要有以下两方面：
     (1)IO瓶颈
     (2)锁性能差
2.对SP的不当封装也会间接造成数据读写性能差。

```

```
SharedPreferences数据写入磁盘也有两个方法会触发：
     (1)Editor的commit方法，每次执行时同步写入磁盘。
     (2)Editor的apply方法，每次执行时在单线程池中加入写入磁盘Task，异步写入。
     commit和apply的方法区别在于同步写入和异步写入，以及是否需要返回值。
     在不需要返回值的情况下，使用apply方法可以极大的提高性能。
     同时，多个写入操作可以合并为一个commit/apply，将多个写入操作合并后也能提高IO性能。


public interface SharedPreferences {
    void registerOnSharedPreferenceChangeListener(SharedPreferences.OnSharedPreferenceChangeListener var1);   【 注册 SharePreference 变化监听器 】
    void unregisterOnSharedPreferenceChangeListener(SharedPreferences.OnSharedPreferenceChangeListener var1);

    public interface OnSharedPreferenceChangeListener {
        void onSharedPreferenceChanged(SharedPreferences var1, String var2);
    }


    String getString(String var1, String var2);      【 SharedPreferences 用于读取数据的方法】
    Set<String> getStringSet(String var1, Set<String> var2);
    int getInt(String var1, int var2);
    long getLong(String var1, long var2);
    float getFloat(String var1, float var2);
    boolean getBoolean(String var1, boolean var2);
    boolean contains(String var1);

    public interface Editor {  // 【SharedPreferences.Editor 是专门用来写数据的类】
        SharedPreferences.Editor putString(String var1, String var2);
        SharedPreferences.Editor putStringSet(String var1, Set<String> var2);
        SharedPreferences.Editor putInt(String var1, int var2);
        SharedPreferences.Editor putLong(String var1, long var2);
        SharedPreferences.Editor putFloat(String var1, float var2);
        SharedPreferences.Editor putBoolean(String var1, boolean var2);
        SharedPreferences.Editor remove(String var1);
        SharedPreferences.Editor clear();

        boolean commit();  // 同步写入磁盘操作  程序需要等待运行结果返回 判断是否写入成功
        void apply();   // 异步写入磁盘操作   没有返回值
    }

}

```
```
使用SharePreference的方法：
【1. 创建SharePreference 并写入数据】
//   Context.getSharedPreferences 
SharedPreferences mSharedPreferences = getSharedPreferences("zukgit", Context.MODE_PRIVATE);
Editor editor = mSharedPreferences.edit();       
editor.putInt("user_id", 1);
editor.putString("user_mobile","13811111111");
editor.commit();

【2. 读取SharePreference 的方法 】

SharedPreferences share=getSharedPreferences("zukgit",Context.MODE_WORLD_READABLE);

String str=share.getString("str","");
HashSet<String>  set = share.getStringSet("stringArr", null);
int i=share.getInt("i",0);
long longValue = share.getLong("longValue", 0L);
float floatValue = getFloat("floatValue", 0.0f);
boolean flag=share.getBoolean("flag",false)；

```

```
SharedPreferences实例：

    @Override
    protected void onStart() {
 // 在  /data/data/<package_name>/shared_prefs 创建一个名字为 zukgit 的 xml文件  模式 MODE_PRIVATE  目前新版本只有该一种模式
        SharedPreferences mSP = getSharedPreferences("zukgit",MODE_PRIVATE);  
        SharedPreferences.Editor  editor = mSP.edit();

        editor.putBoolean("zukgit_isMan", true);
        editor.putInt("zukgit_ID", 1);
        editor.putString("zukgit_Name", "zukgit");
        Set set= new HashSet<String>();
        set.add("zzq");
        set.add("zwt");
        editor.putStringSet("zukgit_brothers", set );
        editor.putLong("zukgit_livingDay", 26*365 );
        editor.putFloat("zukgit_PI", 3.14f);

        boolean flag = editor.commit();  // 同步提交 有返回值 boolean 表示提交是否成功
        // editor.apply();  异步提交到磁盘 无返回值
}



    @Override
    protected void onPause() {
        super.onPause();

        boolean booleanValue = mSP.getBoolean("zukgit_isMan",false);
        int intValue = mSP.getInt("zukgit_ID",0);
        String stringValue = mSP.getString("zukgit_Name","");
        HashSet<String> hashSetValue = (HashSet<String>) mSP.getStringSet("zukgit_brothers",null);
        long longValue = mSP.getLong("zukgit_livingDay",0L);
        float floatValue =  mSP.getFloat("zukgit_PI",0F);
        android.util.Log.i("zukgit",booleanValue?" booleanValue==true":" booleanValue==false");
        android.util.Log.i("zukgit","intValue == "+ intValue);
        android.util.Log.i("zukgit","stringValue == "+ stringValue);
        android.util.Log.i("zukgit","hashSetValue == "+ Arrays.toString(hashSetValue.toArray()));
        android.util.Log.i("zukgit","longValue == "+ longValue);
        android.util.Log.i("zukgit","floatValue == "+ floatValue);

}


打印Log：

I/zukgit:  booleanValue==true
I/zukgit: intValue == 1
I/zukgit: stringValue == zukgit
I/zukgit: hashSetValue == [zwt, zzq]
I/zukgit: longValue == 9490
I/zukgit: floatValue == 3.14



生成的文件为：


/data/data/xxxxxxxx/shared_prefs/zukgit.xml
<?xml version='1.0' encoding='utf-8' standalone='yes' ?>
<map>
    <set name="zukgit_brothers">
        <string>zwt</string>
        <string>zzq</string>
    </set>
    <int name="zukgit_ID" value="1" />
    <string name="zukgit_Name">zukgit</string>
    <long name="zukgit_livingDay" value="9490" />
    <float name="zukgit_PI" value="3.14" />
    <boolean name="zukgit_isMan" value="true" />
</map>


```
##  String产生对象问题


对于字符串：
其对象的引用都是存储在栈中的 String s    Static String s 都是，
如果是【编译期已经创建好(直接用双引号定义的)的就存储在常量池中】 
           包括  Static String s="Hello World"   method(){ String str="Hello World"}   new String("Hello World") 中的"" 引号内字符串
如果是【运行期（new出来的）才能确定的就存储在堆中】。对于equals相等的字符串，在常量池中永远只有一份，在堆中有多份。 new String() 存储在堆中


<img src="http://host805073097.s507.pppf.com.cn/wp-content/image/xiaoxijie/string.png">
```

public class String_Test {

	
	static  String static_str1 = "Hello World!";  // 静态字符串  存储在常量池  并且 只会有一个对象
	static  String static_str2 = "Hello World!";   // static_str1 和 static_str2 都指向 常量池常量  "Hello World!"

	public static void main(String[] args) {
	
	// 以常量池中的 "Hello World!" 创建一个 堆中的 String对象 ，如果常量池没有"" 引号对象  那么就会在常量池创建 如 "Hello Zukgit!"
		String str1 = new String("Hello World!");  

		String str2 = new String("Hello World!");

		String str3 ="Hello World!";
		String str4 ="Hello Zukgit!";  // 将会在常量池中创建 对象
		
		System.out.println(static_str1 =="Hello World!" ? "static_str1 ==\"Hello World!\"":"static_str1 !=\"Hello World!\"");
		System.out.println(static_str1 ==static_str2 ? "static_str1 ==static_str1":"static_str1 !=static_str2");
		System.out.println(static_str2 =="Hello World!" ? "static_str2 ==\"Hello World!\"":"static_str2 !=\"Hello World!\"");

		
		System.out.println(static_str1 ==str1 ? "static_str1 ==str1":"static_str1 !=str1");
		System.out.println(str1 ==str2 ? "str1 ==str2":"str1 !=str2");		System.out.println(str1 ==str3 ? "str1 ==str3":"str1 !=str3");
		System.out.println(str2 ==str3 ? "str2 ==str3":"str2 !=str3");	
		
		
		
		System.out.println(static_str1 ==str3 ? "static_str1 ==str3":"static_str1 !=str3");	
		System.out.println(static_str2 ==str3 ? "static_str2 ==str3":"static_str2 !=str3");	
		
}
	
}

/*
 * 输出：
 * 
static_str1 =="Hello World!" //【常量池中的 对象 相等】
static_str1 ==static_str1 //【常量池中的 对象 相等】
static_str2 =="Hello World!"  //【常量池中的 对象 相等】
static_str1 !=str1        // 【常量池中的对象static_str1   与 堆中的对象str1  不相等 】
str1 !=str2              // 【堆中的对象str1   与 堆中的对象str2  是两个对象  内存地址不相等 】
str1 !=str3             // 【堆中的对象str1   与 堆中的对象str2  是两个对象  内存地址不相等 】
str2 !=str3            // 【堆中的对象str1   与 堆中的对象str2  是两个对象  内存地址不相等 】
static_str1 ==str3    //【常量池中的 对象 相等】
static_str2 ==str3   //【常量池中的 对象 相等】
 * 
 * 
 * 
 * */



```



# T
## Top-level classes 和 Inner classes
[内部类脑图](http://naotu.baidu.com/file/dfe548a454e761c4864082de6316120c)
<img src="http://host805073097.s507.pppf.com.cn/wp-content/image/xiaoxijie/view.png">
```
Top-level classes: 指可以被声明为包成员,文件名字就是类名字的顶级文件。每一个top-level类对应于一个文件名与类名相同的java文件
因为top-level class已经是top-level，所以没必要声明为static。■ 如果把top-level class声明为static，编译器会报错。 接口java文件 声明为static 编译器会报错

■Inner classes： 内部类
在top-level class中可以定义inner class，根据inner class定义方式的不同，inner class可以有如下四种形式：

1.Anonymous匿名类   【因为匿名类没有标准的类声明，所以不可以声明为static】   匿名类没有static的说法
okButton.addActionListener( new ActionListener(){  
   public void actionPerformed(ActionEvent e){  
      dispose();  
   }  
});    

2. Local 局部类： 在函数中new 出来的类
就像局部变量一样，局部类不能声明为public,private,protected或static。
 method(){
List list1 = new List();  
}


3.Member 成员类：
成员类_内部类 是唯一可以声明为static类，当把成员类声明为static的时候，它就变成top-level class。成员类_内部类 没有被声明为static  那么它就是普通的 内部类_成员类


4. 静态内部类


```


```
输出结果：
======================Outter static block begin======================
Outter => static_byte_Outter_Init== 0x0f
Outter => static_byte_Outter_Default 静态属性初始化默认值== 0x00
Outter => static_boolean_Outter_Init== false
Outter => static_boolean_Outter_Default 静态属性初始化默认值== false
Outter => static_char_Outter_Init== a
Outter => static_char_Outter_Default 静态属性初始化默认值== 
Outter => static_short_Outter_Init== 1
Outter => static_short_Outter_Default 静态属性初始化默认值== 0
Outter => static_int_Outter_Init== 100
Outter => static_int_Outter_Default 静态属性初始化默认值== 0
Outter => static_long_Outter_Init== 10000
Outter => static_long_Outter_Default 静态属性初始化默认值== 0
Outter => static_float_Outter_Init== 3.1415
Outter => static_float_Outter_Default 静态属性初始化默认值== 0.0
Outter => static_double_Outter_Init== 3.1415926
Outter => static_double_Outter_Default 静态属性初始化默认值== 0.0
Outter => static_String_Outter_Init== Outter => static_String_Outter_Init 
Outter => static_String_Outter_Default 静态属性初始化默认值== null
======================Outter static block end======================
############################Outter out =new Outter(); Begin  ################################
======================Outter object block begin======================
Outter =>  byte_Outter_Init== 0x02
Outter =>  byte_Outter_Default 对象初始化默认值== 0x00
Outter =>  boolean_Outter_Init== true
Outter =>  boolean_Outter_Default 对象初始化默认值== false
Outter =>  char_Outter_Init== b
Outter =>  char_Outter_Default 对象初始化默认值== 
Outter =>  short_Outter_Init== 2
Outter =>  short_Outter_Default 对象初始化默认值== 0
Outter =>  int_Outter_Init== 200
Outter =>  int_Outter_Default 对象初始化默认值== 0
Outter =>  long_Outter_Init== 200000
Outter =>  long_Outter_Default 对象初始化默认值== 0
Outter =>  float_Outter_Init== 6.283
Outter =>  float_Outter_Default 对象初始化默认值== 0.0
Outter =>  double_Outter_Init== 6.28302945
Outter =>  double_Outter_Default 对象初始化默认值== 0.0
Outter =>  String_Outter_Init== Outter => String_Outter_Init 
Outter =>  String_Outter_Default 对象初始化默认值== null
======================Outter object block end======================
=================== Outter 构造函数  Begin===================
=================== Outter 构造函数  End===================
############################Outter out =new Outter(); End  ################################
############################Inner_Interface Implement Begin  ################################
String_Inner_Interface
Inner_Interface =>  String_static_Inner_Interface
======================Inner_Interface_static_implementMethod begin======================
String_Inner_Interface
Inner_Interface =>  String_static_Inner_Interface
======================Inner_Interface_static_implementMethod end======================
############################Inner_Interface Implement End  ################################
@@@@@@@@@@@@@@@@@@@@@@@Inner_static_Object String Begin  @@@@@@@@@@@@@@@@@@@@@@@
======================Inner_static_Object static block begin======================
======================Inner_static_Object static block end======================
@@@@@@@@@@@@@@@@@@@@@@@Inner_static_Object String ENd  @@@@@@@@@@@@@@@@@@@@@@@
#############Outter.Inner_static_Object.Inner_static_Object_static_method() BEGIN ################
======================Inner_static_Object_method begin======================
 Inner_static_Object =>  String_static_Inner_static_Object  <Inner_static_Object staic block>
======================Inner_static_Object_method end======================
#############Outter.Inner_static_Object.Inner_static_Object_static_method() END ################
############################new Inner_static_Object(); Begin  ################################
======================Inner_static_Object  object block begin======================
======================Inner_static_Object  object block end======================
############################new Inner_static_Object(); End  ################################
############################ mInner_static_Object.Inner_static_Object_method  Begin  ################################
======================Inner_Object_method begin======================
 Inner_static_Object =>  String_static_Inner_static_Object  <Inner_static_Object staic block> <Inner_static_Object object block>
Inner_static_Object =>  String_Inner_static_Object <Inner_static_Object object block>
======================Inner_Object_method end======================
############################ mInner_static_Object.Inner_static_Object_method  End  ################################
##############Outter.Inner_Object  mInner_Object = out.new Inner_Object()  Begin ###################
======================Inner_Object block begin======================
 Inner_Object =>  String_static_Inner_Object
Inner_Object =>  String_Inner_Object
======================Inner_Object block end======================
Inner_Object =>  String_Inner_Object
Object方式访问非静态内部类静态成员: Inner_Object =>  String_static_Inner_Object
Class方式访问非静态内部类静态成员:a Inner_Object =>  String_static_Inner_Object
##############Outter.Inner_Object  mInner_Object = out.new Inner_Object()  END ###################



```
```
package test;



public   class Outter {
	
	// =================== Outter 构造函数  Begin===================
	public Outter() {
		System.out.println("=================== Outter 构造函数  Begin===================");
		System.out.println("=================== Outter 构造函数  End===================");
		
	}
	// =================== Outter 构造函数  End===================
	
	
	// =================== Propertys  Begin===================
	 // byte boolean char  short  int  long    float double  String   
static byte static_byte_Outter_Init =  0x0F;     // 声明时初始化的静态属性  byte
static byte static_byte_Outter_Default ;   // 声明时就不初始化的静态属性 byte
byte byte_Outter_Init = 0x02;                // 声明时初始化的对象属性     byte  
byte byte_Outter_Default;              // 声明时不初始化的对象属性    byte


static boolean static_boolean_Outter_Init = false;     // 声明时初始化的静态属性  boolean
static boolean static_boolean_Outter_Default ;   // 声明时就不初始化的静态属性 boolean
boolean boolean_Outter_Init = true;                // 声明时初始化的对象属性     boolean  
boolean boolean_Outter_Default;              // 声明时不初始化的对象属性    boolean

static char static_char_Outter_Init ='a';     // 声明时初始化的静态属性  char
static char static_char_Outter_Default;   // 声明时就不初始化的静态属性 char
char char_Outter_Init = 'b';                  // 声明时初始化的对象属性     char  
char char_Outter_Default;              // 声明时不初始化的对象属性    char

static short static_short_Outter_Init = 1;     // 声明时初始化的静态属性  short
static short static_short_Outter_Default;   // 声明时就不初始化的静态属性 short
short short_Outter_Init = 2 ;                // 声明时初始化的对象属性     short  
short short_Outter_Default;              // 声明时不初始化的对象属性    short



static int static_int_Outter_Init = 100;     // 声明时初始化的静态属性  int
static int static_int_Outter_Default;   // 声明时就不初始化的静态属性 int
int int_Outter_Init =200;                  // 声明时初始化的对象属性     int
int int_Outter_Default;              // 声明时不初始化的对象属性    int


static long static_long_Outter_Init = 10000L;     // 声明时初始化的静态属性  long
static long static_long_Outter_Default;   // 声明时就不初始化的静态属性 long
long long_Outter_Init = 200000L;                  // 声明时初始化的对象属性     long
long long_Outter_Default;              // 声明时不初始化的对象属性    long


static float static_float_Outter_Init = 3.1415F;     // 声明时初始化的静态属性  float
static float static_float_Outter_Default;   // 声明时就不初始化的静态属性 float
float float_Outter_Init  = 6.2830F;                  // 声明时初始化的对象属性     float
float float_Outter_Default;              // 声明时不初始化的对象属性    float


static double static_double_Outter_Init =  3.1415926D;     // 声明时初始化的静态属性  double
static double static_double_Outter_Default;   // 声明时就不初始化的静态属性 double
double double_Outter_Init = 6.28302945D;                 // 声明时初始化的对象属性     double
double double_Outter_Default;              // 声明时不初始化的对象属性    double

static String static_String_Outter_Init = "Outter => static_String_Outter_Init ";     // 声明时初始化的静态属性  String
static String static_String_Outter_Default;   // 声明时就不初始化的静态属性 String
String String_Outter_Init ="Outter => String_Outter_Init ";                  // 声明时初始化的对象属性     String
String String_Outter_Default;              // 声明时不初始化的对象属性    String

	// =================== Propertys  End===================
 
 




	// =================== Block  Begin===================
static { 
	System.out.println("======================Outter static block begin======================");
	System.out.println("Outter => static_byte_Outter_Init== "+byteToHex(static_byte_Outter_Init));
	System.out.println("Outter => static_byte_Outter_Default 静态属性初始化默认值== "+byteToHex(static_byte_Outter_Default));
	
	System.out.println("Outter => static_boolean_Outter_Init== "+static_boolean_Outter_Init);
	System.out.println("Outter => static_boolean_Outter_Default 静态属性初始化默认值== "+static_boolean_Outter_Default);
	System.out.println("Outter => static_char_Outter_Init== "+static_char_Outter_Init);
	System.out.println("Outter => static_char_Outter_Default 静态属性初始化默认值== "+static_char_Outter_Default);

	System.out.println("Outter => static_short_Outter_Init== "+static_short_Outter_Init);
	System.out.println("Outter => static_short_Outter_Default 静态属性初始化默认值== "+static_short_Outter_Default);
	
	
	System.out.println("Outter => static_int_Outter_Init== "+static_int_Outter_Init);
	System.out.println("Outter => static_int_Outter_Default 静态属性初始化默认值== "+static_int_Outter_Default);


	System.out.println("Outter => static_long_Outter_Init== "+static_long_Outter_Init);
	System.out.println("Outter => static_long_Outter_Default 静态属性初始化默认值== "+static_long_Outter_Default);
	
	System.out.println("Outter => static_float_Outter_Init== "+static_float_Outter_Init);
	System.out.println("Outter => static_float_Outter_Default 静态属性初始化默认值== "+static_float_Outter_Default);

	
	System.out.println("Outter => static_double_Outter_Init== "+static_double_Outter_Init);
	System.out.println("Outter => static_double_Outter_Default 静态属性初始化默认值== "+static_double_Outter_Default);


	
	System.out.println("Outter => static_String_Outter_Init== "+static_String_Outter_Init);
	System.out.println("Outter => static_String_Outter_Default 静态属性初始化默认值== "+static_String_Outter_Default);
	System.out.println("======================Outter static block end======================");
}
	
 { 
	System.out.println("======================Outter object block begin======================");
	System.out.println("Outter =>  byte_Outter_Init== "+ byteToHex(byte_Outter_Init));
	System.out.println("Outter =>  byte_Outter_Default 对象初始化默认值== "+ byteToHex(byte_Outter_Default));
	
	System.out.println("Outter =>  boolean_Outter_Init== "+ boolean_Outter_Init);
	System.out.println("Outter =>  boolean_Outter_Default 对象初始化默认值== "+ boolean_Outter_Default);
	System.out.println("Outter =>  char_Outter_Init== "+ char_Outter_Init);
	System.out.println("Outter =>  char_Outter_Default 对象初始化默认值== "+ char_Outter_Default);

	System.out.println("Outter =>  short_Outter_Init== "+ short_Outter_Init);
	System.out.println("Outter =>  short_Outter_Default 对象初始化默认值== "+ short_Outter_Default);
	
	
	System.out.println("Outter =>  int_Outter_Init== "+ int_Outter_Init);
	System.out.println("Outter =>  int_Outter_Default 对象初始化默认值== "+ int_Outter_Default);


	System.out.println("Outter =>  long_Outter_Init== "+ long_Outter_Init);
	System.out.println("Outter =>  long_Outter_Default 对象初始化默认值== "+ long_Outter_Default);
	
	System.out.println("Outter =>  float_Outter_Init== "+ float_Outter_Init);
	System.out.println("Outter =>  float_Outter_Default 对象初始化默认值== "+ float_Outter_Default);

	
	System.out.println("Outter =>  double_Outter_Init== "+ double_Outter_Init);
	System.out.println("Outter =>  double_Outter_Default 对象初始化默认值== "+ double_Outter_Default);


	
	System.out.println("Outter =>  String_Outter_Init== "+ String_Outter_Init);
	System.out.println("Outter =>  String_Outter_Default 对象初始化默认值== "+ String_Outter_Default);
	System.out.println("======================Outter object block end======================");
}
	// =================== Block  End===================
	
	// =================== Inner Interface  Begin===================
	interface Inner_Interface{
         static String String_static_Inner_Interface = "Inner_Interface =>  String_static_Inner_Interface";
         String String_Inner_Interface = "String_Inner_Interface";
		void Inner_Interface_method();

		static void Inner_Interface_static_ImplementMethod() {
			System.out.println("======================Inner_Interface_static_implementMethod begin======================");
			System.out.println(String_Inner_Interface);
			System.out.println(String_static_Inner_Interface);
			System.out.println("======================Inner_Interface_static_implementMethod end======================");
		}
	}
	
	// =================== Inner Interface  End===================
	
	
	// =================== Inner_static_Object  Begin===================
	
	static class Inner_static_Object{
		  static String  String_static_Inner_static_Object = " Inner_static_Object =>  String_static_Inner_static_Object" ;
	        String String_Inner_static_Object = "Inner_static_Object =>  String_Inner_static_Object";
		  
		  
	        static {
				 System.out.println("======================Inner_static_Object static block begin======================");
				 
				 String_static_Inner_static_Object = String_static_Inner_static_Object +"  <Inner_static_Object staic block>";
				 System.out.println("======================Inner_static_Object static block end======================");
				 
	        }
	        
	        
	        {
				 System.out.println("======================Inner_static_Object  object block begin======================");
				 String_Inner_static_Object = String_Inner_static_Object +" <Inner_static_Object object block>";
				 String_static_Inner_static_Object = String_static_Inner_static_Object +" <Inner_static_Object object block>";
				 System.out.println("======================Inner_static_Object  object block end======================");
	        }
	        
	        
		 static	void Inner_static_Object_static_method(){
			 System.out.println("======================Inner_static_Object_method begin======================");
			 System.out.println(String_static_Inner_static_Object);
			 System.out.println("======================Inner_static_Object_method end======================");
			 }
		 
		 void Inner_static_Object_method(){
			 System.out.println("======================Inner_Object_method begin======================");
			 System.out.println(String_static_Inner_static_Object);
			 System.out.println(String_Inner_static_Object);
			 System.out.println("======================Inner_Object_method end======================");
			 }
		 
	}
	// =================== Inner_static_Object  End===================
	
	// =================== Inner_Object  Begin===================
	class Inner_Object{

		  final static String  String_static_Inner_Object = " Inner_Object =>  String_static_Inner_Object" ;
	      String String_Inner_Object = "Inner_Object =>  String_Inner_Object";
		  
	      
	      {
				 System.out.println("======================Inner_Object block begin======================");
				 System.out.println(String_static_Inner_Object);
				 System.out.println(String_Inner_Object);
				 System.out.println("======================Inner_Object block end======================");
	    	  
	      }
			 void Inner_Object_method(){
				 System.out.println("======================Inner_Object_method begin======================");
				 System.out.println(String_static_Inner_Object);
				 System.out.println(String_Inner_Object);
				 System.out.println("======================Inner_Object_method end======================");
				 }
			 	 
	        
	}
	
	// =================== Inner_Object  End===================


final static char[] hexArray = "0123456789ABCDEF".toCharArray();  
public static String bytesToHex(byte[] bytes) {
    char[] hexChars = new char[bytes.length * 2];  
    for ( int j = 0; j < bytes.length; j++ ) {  
        int v = bytes[j] & 0xFF;  
        hexChars[j * 2] = hexArray[v >>> 4];  
        hexChars[j * 2 + 1] = hexArray[v & 0x0F];  
    }  
    return new String(hexChars);  
}  


public static String byteToHex(byte  byteValue) {
	return byteValue > 0x0f || byteValue < 0x00 ? "0x"+Integer.toHexString(byteValue & 0xff ) : "0x0"+Integer.toHexString(byteValue & 0xff);

}  




public static void main(String[] args) {
	System.out.println("############################Outter out =new Outter(); Begin  ################################");
	Outter out =new Outter();
	System.out.println("############################Outter out =new Outter(); End  ################################");
	
	
	System.out.println("############################Inner_Interface Implement Begin  ################################");
	
	 Inner_Interface interfaceObj = new Inner_Interface(){
		@Override
		public void Inner_Interface_method() {
		}
	};
	
	System.out.println(interfaceObj.String_Inner_Interface);
	System.out.println(interfaceObj.String_static_Inner_Interface);
	
	Inner_Interface.Inner_Interface_static_ImplementMethod();
	System.out.println("############################Inner_Interface Implement End  ################################");
	
	// 当第一次 调用 内部静态类的静态代码 静态属性时候 会触发 static{} 代码块的执行
	// 静态代码块 只会执行一次
	
	System.out.println("@@@@@@@@@@@@@@@@@@@@@@@Inner_static_Object String Begin  @@@@@@@@@@@@@@@@@@@@@@@");
	String str = Outter.Inner_static_Object.String_static_Inner_static_Object;
	System.out.println("@@@@@@@@@@@@@@@@@@@@@@@Inner_static_Object String ENd  @@@@@@@@@@@@@@@@@@@@@@@");
	System.out.println("#############Outter.Inner_static_Object.Inner_static_Object_static_method() BEGIN ################");
	Outter.Inner_static_Object.Inner_static_Object_static_method(); 
	System.out.println("#############Outter.Inner_static_Object.Inner_static_Object_static_method() END ################");
	
	
	
	System.out.println("############################new Inner_static_Object(); Begin  ################################");
	Outter.Inner_static_Object  mInner_static_Object = new Inner_static_Object();
	System.out.println("############################new Inner_static_Object(); End  ################################");
	
	System.out.println("############################ mInner_static_Object.Inner_static_Object_method  Begin  ################################");
	mInner_static_Object.Inner_static_Object_method();
	System.out.println("############################ mInner_static_Object.Inner_static_Object_method  End  ################################");


	
	System.out.println("##############Outter.Inner_Object  mInner_Object = out.new Inner_Object()  Begin ###################");

	// 创建内部非静态类
	Outter.Inner_Object  mInner_Object = out.new Inner_Object();
	System.out.println(mInner_Object.String_Inner_Object);
	System.out.println("Object方式访问非静态内部类静态成员:"+mInner_Object.String_static_Inner_Object);
	System.out.println("Class方式访问非静态内部类静态成员:a"+Outter.Inner_Object.String_static_Inner_Object);
	System.out.println("##############Outter.Inner_Object  mInner_Object = out.new Inner_Object()  END ###################");
}


}


//  java byte b = 0x80；为什么会报错 ?
// 因为什么0x 开头的是16进制,编译的时候会自动转成整数,而这个整数超过了byte的长度(byte取值范围是-128 ~ 127), 
// 而0x80转为十进制 = 128所以报损失精度了,编译不过的


// 当第一次 调用 内部静态类的静态代码 静态属性时候 会触发 static{} 代码块的执行
// 静态代码块 只会执行一次


```
## Top-level Class's InnerClass 静态内部类相互继承 包含同名同方法的案例
静态内部类继承关系  
User extends Person 
User 和 Person 有相同的属性  那么 User的属性会替换Person的属性   在Person中 其实会调用到 User的属性
■ User的对象属性 的初始化阶段 【 相当于 {}  Object Block】 在父类构造器完成之后，在自身构造器完成之前
```
public class OutterObject {

	static class Person {
		String name = "Person";
		int age = 26;
		
		{
			System.out.println("===============Person.Block Begin ===============");
			System.out.println("===============Person.Block END ===============");
		}
		public Person() {
			System.out.println("===============Person() begin===============");
			init();
			System.out.println("===============Person() end===============");
		}

		protected void init() {
			System.out.println("===============Person.init()  begin===============");
			System.out.println("Person.name:" + name + "  Person.age:" + age);
			System.out.println("===============Person.init()  end===============");
		}
	}

	static class User extends Person {

		
		String name = "User";
		int age = 27;  
		
		{
			System.out.println("===============User.Block Begin ===============");
			System.out.println("===============User.Block END ===============");
		}
		
		public User() {  //【 User() 构造器默认是首先调用 super()  所以不管有没有写super() 效果都是一样的 】
			System.out.println("===============User() Begin ===============");
			init();
			System.out.println("===============User() End ===============");
		}

		protected void init() {
			System.out.println("===============User() init Begin===============");
			super.init();
			System.out.println("User.name:" + name + "  User.age:" + age);
			System.out.println("===============User() init END===============");

		}
	}

	public static void main(String[] args) {
		User user = new User();  
	}
}

输出： 
===============Person.Block Begin ===============   【1. 父类的对象属性会被最先初始化  如果有静态属性那么会先初始化静态属性】
===============Person.Block END ===============
===============Person() begin===============           【2. 父类的构造器开始执行  由于存在方法的重写 】  父类和子类同名同参数的方法
===============User() init Begin===============          【3. 父类调用子类重写的方法】
===============Person.init()  begin===============          【4. 通过 super().init() 显示的调用父类的 init 方法】
Person.name:Person  Person.age:26                【5. 父类的对象属性已经首先初始化了  所以能打印出父类初始化的值】
===============Person.init()  end===============       【父类的 init函数完成】
User.name:null  User.age:0                        【6. 返回到super().init()的下一条语句   由于Person父类的构造器还没完成 所以 子类的属性都是为空的  打印空 】
===============User() init END===============
===============Person() end===============     【父类的构造器完成】
===============User.Block Begin ===============  【子类的 Block块 初始化操作开始】
===============User.Block END ===============
===============User() Begin ===============        【子类的构造器开始】
===============User() init Begin===============           【7. User 构造器中的 init() 代码开始执行 方法】
===============Person.init()  begin===============
Person.name:Person  Person.age:26                          【8. User的init()方法 通过 super.init() 现实的调用父类的 init()方法 再一次执行父类的属性的打印】
===============Person.init()  end===============
User.name:User  User.age:27                                 【9. 通过 System.out.println("User.name:" + name + "  User.age:" + age); 打印出自己的属性】
===============User() init END===============
===============User() End ===============


多态存在的三个必要条件：要有继承、要有重写、父类变量引用子类对象。
方法覆盖重写要求参数列表必须一致，而方法重载要求参数列表必须不一致。
通过子类的引用访问同名方法时，默认是重写之后的同名方法。如果还要访问父类的同名方法，可以【使用super关键字来显示调用】。 
访问

结论 :
1.父类与子类定义同名的变量，并不会覆盖，而是各自还有自己的空间，即使变量名相同
2.相同方法的情况下  父类方法调用的是子类重载的方法 


```

##  Thread 和 Runnable的关系
```
1. 线程实现了 Runnable接口       线程的优先级  数值越大 优先级越大 
public class Thread implements Runnable {  
    public static final int MIN_PRIORITY = 1;
    public static final int NORM_PRIORITY = 5;
    public static final int MAX_PRIORITY = 10;
}

2. 接口内定义了 run()方法
public interface Runnable {
    void run();
}

3. 外界通过 start() 方法最终调用到 run() 方法 内 执行自定义代码
    public synchronized void start() {
    }

4. sleep() 是Thrad类的静态方法  不是Object的方法 区别于 object的 wait() 方法
    public static void sleep(long time) throws InterruptedException {
    }

5.Thread.yield()方法作用是：暂停当前正在执行的线程对象（及放弃当前拥有的cup资源），并执行其他线程    
yield()做的是让当前运行线程回到可运行状态 【正在运行状态 --> 可运行状态】，以允许具有相同优先级的其他线程获得运行机会。
    public static void yield() {
    }

使用yield()的目的: 
是让相同优先级的线程之间能适当的轮转执行
但是，实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中
结论：yield()从未导致线程转到等待/睡眠/阻塞状态。在大多数情况下，yield()将导致线程从运行状态转到可运行状态，但有可能没有效果



6. 实例   new Thread( new ThreadChild（）)

package test;

public class ThreadObj extends Thread{
	public static void main(String[] args) {
		ThreadObj mThreadObj = new ThreadObj();

  // 以Thread父类 ThreadObj 为参数  构建 Thread ， 实际执行的方法是  public Thread(Runnable runnable) {} 构造函数
// 把 Thread父类 ThreadObj 当做一个 Runnable 接口的实例 去创建 Thread ，因为 public class Thread implements Runnable  ，Thrad定义时就已经实现Runnable方法
		Thread thrad = new Thread(mThreadObj);
		thrad.start();
	}
	
	public void run(){   // 子类重写的 run() 方法   重写是 面向对象特征之一 实现多态
		for(int i =0 ; i <3 ; i++)
		System.out.println(i+"..");
	}
}


```
## Time时间复杂度  和 空间复杂度
[时间复杂度](https://www.jianshu.com/p/f4cca5ce055a)
[时间复杂度](https://www.zhihu.com/question/21387264)
<img src="https://pic2.zhimg.com/80/v2-8c710914a7d092296dd4c2eadb525dcd_hd.jpg">
<img src="https://pic1.zhimg.com/80/v2-a1387c0df75b3bc0fc81285efd0fed70_hd.jpg">
```
时间复杂度：          关系函数  T(n)=O(f(n))  我们研究当N 不断增大时  T与N的关系映射
时间复杂度就是问题规模N对时间的映射T.  O只是去掉杂项


1. 常数级别
T(n) = O(1) = C;   表示当 常数级别的运算时，N的值不断增大  T的花费时间变化很小 如图 常数级别
T = O(N + 100)；

2.对数级别
T(n) = O(Log N) = C LogN;   表示当 常数级别的运算时，N的值不断增大  T的花费时间变化很小 比常熟级别大  如图
T = O(log N )；

3. 线性级别：
T(n) = O( N) = C N;     时间复杂度如图
T = O( 10 * N )


4. 线性对数级别
T(n) = O( N * log N ) = C N loh N;     时间复杂度如图
T = O( 10 * log N )

5.平方级别
T(n) = O(n²) = Cn² :  表示当n很大 持续增大 的时候，复杂度约等于Cn²，C是某个常数，简单说就是当n足够大的时候，n的线性增长，复杂度将沿平方增长。
T = O( N * N )   时间复杂度如图
1+2+3+4+……+n =(1+n)*n/2  = O(n²) =  Cn² 的复杂度

6.立方级别
T = O( N * N * N) =CN^3      时间复杂度如图   N变动幅度小   T变动幅度大

7.指数级别         
T(n) = O(2^n) = Cn² :       时间复杂度最高  
T = O(  2 ^ N ) 
```


```
当评价一个算法的时间复杂度时： 就是从 以下七个复杂度回答一个对应的代码类型的复杂度  如上图示例代码
1.常数级别     O(1) = C; 
2.对数级别     O(Log N) = C LogN;
3.线性级别     O(N) = C N;
4.线性对数级别  O(N*logN) = C N*log N; 
5.平方级别        O(n²) = Cn² ;               1+2+3+4+……+n =(1+n)*n/2  = O(n²) =  Cn² 的复杂度
6.立方级别       O( n³) =Cn³ ;
7.指数级别       O(2ⁿ) = C2ⁿ ;
```
# U
# V
# W
# X
## XML中 @、@android:type、@*android:type、？、@+含义和区别
```
【@】:  @代表引用资源
1.引用自定义资源。格式：@[package:]type/name
android：text="@string/hello"

2.引用系统资源。格式：@android:type/name
android:textColor="@android:color/opaque_red"    
{ 其实@android:type/name是@[package:]type/name 的一个子类 }

type 包括： attr , id  , style  , string  , dimen , integer , array , drawable , layout , interpolator , mipmap , transition
@android:attr/theme   属性类型




```
```
【@* 】:  @* @*代表引用系统的非public资源。格式：@*android:type/name
格式：@*android:type/name

■系统资源定义分public和非public 。 public的声明在：  <sdk_path>\platforms\android-8\data\res\values\public.xml  【文件 简略在底部】
@*android:type/name：可以调用系统定义的所有资源
@android:type/name：只能够调用publi属性的资源。 
```
 <font color="red"> 没在public.xml中声明的资源是google不推荐使用的。</font>

```
【? 】:  ？问号代表引用主题属性
View中的某些属性 允许你引用当前主题定义属性的值
这个属性值只能在style资源和XML属性中使用 用于修饰View
它允许你通过将它们改变为当前主题提供的标准变化来改变UI元素的外观，■ 而不是提供具体的值   依据当前主题的对应属性决定UI的对应属性
 android:textColor="?android:textDisabledColor" 
【这和资源引用非常类似，除了我们使用一个"?"前缀代替了"@" 】
```

```
【@+ 】: @+代表在创建或引用资源 。格式：@+type/name
”+” 表示在R.java中名为type的内部类中添加一条记录。如"@+id/button"的含义是在R.java 文件中的id 这个静态内部类添加一条常量名为button
该常量就是该资源的标识符。如果标示符（包括系统资源）已经存在则表示引用该标示符。最常用的就是在定义资源ID中

@+id/资源ID名         新建一个资源ID
@id/资源ID名          应用现有已定义的资源ID，包括系统ID
@android:id/资源ID名   引用系统ID，其等效于@id/资源ID名

android:id="@+id/selectdlg"
android:id="@android:id/text1"
android:id="@id/button3"  

```





```
Android\sdk\platforms\android-26\data\res\values\public.xml 大致内容如下：

<?xml version="1.0" encoding="utf-8"?>
<resources>
  <eat-comment />
<!-- type="attr" Begin  -->
  <public type="attr" name="theme" id="0x01010000" />
  <public type="attr" name="label" id="0x01010001" />
  <public type="attr" name="icon" id="0x01010002" />
  <public type="attr" name="name" id="0x01010003" />
  <public type="attr" name="manageSpaceActivity" id="0x01010004" />
  <public type="attr" name="allowClearUserData" id="0x01010005" />
  <public type="attr" name="permission" id="0x01010006" />
  <public type="attr" name="readPermission" id="0x01010007" />
  <public type="attr" name="writePermission" id="0x01010008" />
  <public type="attr" name="protectionLevel" id="0x01010009" />
  <public type="attr" name="permissionGroup" id="0x0101000a" />
   ...............
<!-- type="attr" End  -->

<!-- type="id" Begin  -->
  <public type="id" name="background" id="0x01020000" />
  <public type="id" name="checkbox" id="0x01020001" />
  <public type="id" name="content" id="0x01020002" />
  <public type="id" name="edit" id="0x01020003" />
  <public type="id" name="empty" id="0x01020004" />
  <public type="id" name="hint" id="0x01020005" />
  <public type="id" name="icon" id="0x01020006" />
  <public type="id" name="icon1" id="0x01020007" />
  <public type="id" name="icon2" id="0x01020008" />
  <public type="id" name="input" id="0x01020009" />
  <public type="id" name="list" id="0x0102000a" />
  <public type="id" name="message" id="0x0102000b" />
  <public type="id" name="primary" id="0x0102000c" />
  <public type="id" name="progress" id="0x0102000d" />
  <public type="id" name="selectedIcon" id="0x0102000e" />
  <public type="id" name="secondaryProgress" id="0x0102000f" />
  <public type="id" name="summary" id="0x01020010" />
  <public type="id" name="tabcontent" id="0x01020011" />
  <public type="id" name="tabhost" id="0x01020012" />
  <public type="id" name="tabs" id="0x01020013" />
  <public type="id" name="text1" id="0x01020014" />
  <public type="id" name="text2" id="0x01020015" />
  <public type="id" name="title" id="0x01020016" />
  <public type="id" name="toggle" id="0x01020017" />
  <public type="id" name="widget_frame" id="0x01020018" />
  <public type="id" name="button1" id="0x01020019" />
  <public type="id" name="button2" id="0x0102001a" />
  <public type="id" name="button3" id="0x0102001b" />
<!-- type="id" End  -->

<!-- type="style" Begin  -->
  <public type="style" name="Animation" id="0x01030000" />
  <public type="style" name="Animation.Activity" id="0x01030001" />
  <public type="style" name="Animation.Dialog" id="0x01030002" />
  <public type="style" name="Animation.Translucent" id="0x01030003" />
  <public type="style" name="Animation.Toast" id="0x01030004" />
  <public type="style" name="Theme" id="0x01030005" />
  <public type="style" name="Theme.NoTitleBar" id="0x01030006" />
  <public type="style" name="Theme.NoTitleBar.Fullscreen" id="0x01030007" />
  <public type="style" name="Theme.Black" id="0x01030008" />
  <public type="style" name="Theme.Black.NoTitleBar" id="0x01030009" />
  <public type="style" name="Theme.Black.NoTitleBar.Fullscreen" id="0x0103000a" />
<!-- type="style" End  -->

<!-- type="string" Begin  -->
  <public type="string" name="cancel" id="0x01040000" />
  <public type="string" name="copy" id="0x01040001" />
  <public type="string" name="copyUrl" id="0x01040002" />
  <public type="string" name="cut" id="0x01040003" />
  <public type="string" name="defaultVoiceMailAlphaTag" id="0x01040004" />
  <public type="string" name="defaultMsisdnAlphaTag" id="0x01040005" />
  <public type="string" name="emptyPhoneNumber" id="0x01040006" />
  <public type="string" name="httpErrorBadUrl" id="0x01040007" />
  <public type="string" name="httpErrorUnsupportedScheme" id="0x01040008" />
  <public type="string" name="no" id="0x01040009" />
  <public type="string" name="ok" id="0x0104000a" />
  <public type="string" name="paste" id="0x0104000b" />
  <public type="string" name="search_go" id="0x0104000c" />
  <public type="string" name="selectAll" id="0x0104000d"
<!-- type="string" End  -->

<!-- type="dimen" Begin  -->
  <public type="dimen" name="app_icon_size" id="0x01050000" />
  <public type="dimen" name="thumbnail_height" id="0x01050001" />
  <public type="dimen" name="thumbnail_width" id="0x01050002" />
<!-- type="dimen" End  -->

<!-- type="color" Begin  -->
  <public type="color" name="white" id="0x0106000b" />
  <public type="color" name="black" id="0x0106000c" />
  <public type="color" name="transparent" id="0x0106000d" />
  <public type="color" name="background_dark" id="0x0106000e" />
  <public type="color" name="background_light" id="0x0106000f" />
<!-- type="color" End  -->

<!-- type="array" Begin  -->
  <public type="array" name="emailAddressTypes" id="0x01070000" />
  <public type="array" name="imProtocols" id="0x01070001" />
  <public type="array" name="organizationTypes" id="0x01070002" />
  <public type="array" name="phoneTypes" id="0x01070003" />
  <public type="array" name="postalAddressTypes" id="0x01070004" />
<!-- type="array" End  -->

<!-- type="drawable" Begin  -->
  <public type="drawable" name="alert_dark_frame" id="0x01080000" />
  <public type="drawable" name="alert_light_frame" id="0x01080001" />
  <public type="drawable" name="arrow_down_float" id="0x01080002" />
  <public type="drawable" name="arrow_up_float" id="0x01080003" />
  <public type="drawable" name="btn_default" id="0x01080004" />
  <public type="drawable" name="btn_default_small" id="0x01080005" /
<!-- type="drawable" End  -->


<!-- type="layout" Begin  -->
  <public type="layout" name="activity_list_item" id="0x01090000" />
  <public type="layout" name="expandable_list_content" id="0x01090001" />
  <public type="layout" name="preference_category" id="0x01090002" />
  <public type="layout" name="simple_list_item_1" id="0x01090003" />
  <public type="layout" name="simple_list_item_2" id="0x01090004" />
  <public type="layout" name="simple_list_item_checked" id="0x01090005" />
  <public type="layout" name="simple_expandable_list_item_1" id="0x01090006" />
  <public type="layout" name="simple_expandable_list_item_2" id="0x01090007" />
  <public type="layout" name="simple_spinner_item" id="0x01090008" />
  <public type="layout" name="simple_spinner_dropdown_item" id="0x01090009" />
  <public type="layout" name="simple_dropdown_item_1line" id="0x0109000a" />
  <public type="layout" name="simple_gallery_item" id="0x0109000b" />
  <public type="layout" name="test_list_item" id="0x0109000c" />
  <public type="layout" name="two_line_list_item" id="0x0109000d" />
  <public type="layout" name="browser_link_context_header" id="0x0109000e" />
  <public type="layout" name="simple_list_item_single_choice" id="0x0109000f" />
  <public type="layout" name="simple_list_item_multiple_choice" id="0x01090010" />
  <public type="layout" name="select_dialog_item" id="0x01090011" />
  <public type="layout" name="select_dialog_singlechoice" id="0x01090012" />
  <public type="layout" name="select_dialog_multichoice" id="0x01090013" />
<!-- type="layout" End  -->

<!-- type="anim" Begin  -->
  <public type="anim" name="fade_in" id="0x010a0000" />
  <public type="anim" name="fade_out" id="0x010a0001" />
  <public type="anim" name="slide_in_left" id="0x010a0002" />
  <public type="anim" name="slide_out_right" id="0x010a0003" />
  <public type="anim" name="accelerate_decelerate_interpolator" id="0x010a0004" />
<!-- type="anim" End  -->

<!-- type="integer" Begin  -->
  <public type="integer" name="config_shortAnimTime" id="0x010e0000" />
  <public type="integer" name="config_mediumAnimTime" id="0x010e0001" />
  <public type="integer" name="config_longAnimTime" id="0x010e0002" />
<!-- type="integer" End  -->


<!-- type="interpolator" Begin  -->
  <public type="interpolator" name="decelerate_quad" id="0x010c0001" />
  <public type="interpolator" name="accelerate_cubic" id="0x010c0002" />
  <public type="interpolator" name="decelerate_cubic" id="0x010c0003" />
<!-- type="interpolator" End  -->

<!-- type="mipmap" Begin  -->
  <public type="mipmap" name="sym_def_app_icon" id="0x010d0000" />   【 默认APP 应用图标 】
<!-- type="mipmap" End  -->

<!-- type="transition" Begin  -->
    <public type="transition" name="no_transition" id="0x010f0000" />
    <public type="transition" name="move" id="0x010f0001" />
    <public type="transition" name="fade" id="0x010f0002" />
    <public type="transition" name="explode" id="0x010f0003" />
<!-- type="transition" End  -->

    <public-group type="attr" first-id="0x01010569">
    </public-group>

    <public-group type="style" first-id="0x010302e0">
    </public-group>

    <public-group type="id" first-id="0x01020044">
    </public-group>

    <public-group type="string" first-id="0x0104001a">
    </public-group>
</resources>

```



# Y
# Z